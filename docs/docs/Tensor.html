<!DOCTYPE html><html lang="en">

<head>
  <meta charset="utf-8">
  <title>Tensor</title>
  <link rel="stylesheet" type="text/css" id="preferredStyle" href="../default.css">
  <script>
    /* Updates the stylesheet to use the preferred one.
       Note that we set the link to root ++ sourceLoc because the config
       is shared across the whole website, so the root may differ from
       page to page.
    */
    function setStyleSource (sourceLoc) {
      document.getElementById("preferredStyle").href = "../" + sourceLoc + ".css";
      document.getElementById("selectPreferredStyle").value = sourceLoc;
    }
    /* Initialises the preferred style sheet:
       1. if there is a stored value then use that
          otherwise select the default
       2. set both the css link href & the drop down menu selected option
    */
    function initStyleSource () {
      var preferredStyle = localStorage.getItem("stylefile");
      if (preferredStyle !== null) {
        setStyleSource(preferredStyle);
      } else {
        setStyleSource("default");
      };
    }
    function saveStyleSource (preferredStyle) {
      localStorage.stylefile = preferredStyle;
    }
    </script>
</head>

<body class="namespace">
<header>
  <strong>Idris2Doc</strong> : Tensor
  <nav><a href="../index.html">Index</a>

  <select id="selectPreferredStyle">
    <option value="default">Default</option>
<option value="alternative">Alternative</option>
<option value="blackandwhite">Black & White</option>

  </select>
  </nav>

  <script>
  /* We start by initialising the style source */
  initStyleSource();

  /* This listens for changes on the drop down menu and updates the
     css used for the current page when a selection is made.
  */
  document.getElementById("selectPreferredStyle").addEventListener("change", function(){
    var selected = this.options[this.selectedIndex].value; /* the option chosen */
    setStyleSource (selected);
    saveStyleSource (selected);
  });
</script>

</header>
<div class="container"><div id="module-header"><h1>Tensor</h1><pre>This module contains the `Tensor`, an array of numbers or booleans, along with a
number of functions operating on `Tensor`s. spidr tracks tensor shape and data type in the
types, so you can be sure that if your tensor code compiles, the shapes and types are
consistent.

spidr achieves efficient reuse of tensor computations with `Tag`. See the tutorial
_Nuisances in the Tensor API_ for a discussion of pitfalls to avoid when using `Tag`.
</pre></div><h2>Reexports</h2><code><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Control.Monad.State<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Data.List<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Data.List.Elem<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Literal<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Primitive<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Types<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Util</code><h2>Definitions</h2><dl class="decls"><dt id="Tensor.Tensor"><code><span class="keyword">data</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;:&ensp;<a class="type" href="Types.html#Types.Shape"><span class="name function">Shape</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A scalar or array. Construct a `Tensor` with the function `tensor`.<br>  <br>  @shape The `Tensor` shape.<br>  @dtype The element type.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Constructor</b>:&ensp;<dl class="decls"><dt id="Tensor.MkTensor"><code><a class="type" href="Tensor.html#Tensor.MkTensor"><span class="name constructor">MkTensor</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Expr.html#Compiler.Expr.Expr"><span class="name type">Expr</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt></dl><br>  <b>Hints</b>:<br><dl class="decls">  <dt id="$resolved433"><code><span class="type resolved" title="Prelude.Show.Show"><span class="name type">Show</span></span>&ensp;(<a class="type" href="Tensor.html#Tensor.Tag"><span class="name function">Tag</span></a>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>))</code></dt>  <dt id="$resolved432"><code><a class="type" href="Tensor.html#Tensor.Taggable"><span class="name type">Taggable</span></a>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>)</code></dt></dl></dd><dt id="Tensor.TagT"><code><span class="keyword">data</span>&ensp;<a class="type" href="Tensor.html#Tensor.TagT"><span class="name type">TagT</span></a>&ensp;:&ensp;(<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  The effect of tagging nodes in a computational graph.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Constructor</b>:&ensp;<dl class="decls"><dt id="Tensor.MkTagT"><code><a class="type" href="Tensor.html#Tensor.MkTagT"><span class="name constructor">MkTagT</span></a>&ensp;:&ensp;<span class="type resolved" title="Control.Monad.State.State.StateT"><span class="name type">StateT</span></span>&ensp;<a class="type" href="Compiler.Expr.html#Compiler.Expr.Env"><span class="name type">Env</span></a>&ensp;<span class="boundvar">m</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.TagT"><span class="name type">TagT</span></a>&ensp;<span class="boundvar">m</span>&ensp;<span class="boundvar">a</span></code></dt></dl><br>  <b>Hints</b>:<br><dl class="decls">  <dt id="$resolved437"><code><span class="type resolved" title="Prelude.Interfaces.Monad"><span class="name type">Monad</span></span>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></span>&ensp;(<a class="type" href="Tensor.html#Tensor.TagT"><span class="name type">TagT</span></a>&ensp;<span class="boundvar">m</span>)</code></dt>  <dt id="$resolved436"><code><span class="type resolved" title="Prelude.Interfaces.Functor"><span class="name type">Functor</span></span>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.Functor"><span class="name type">Functor</span></span>&ensp;(<a class="type" href="Tensor.html#Tensor.TagT"><span class="name type">TagT</span></a>&ensp;<span class="boundvar">m</span>)</code></dt>  <dt id="$resolved434"><code><span class="type resolved" title="Prelude.Interfaces.Monad"><span class="name type">Monad</span></span>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.Monad"><span class="name type">Monad</span></span>&ensp;(<a class="type" href="Tensor.html#Tensor.TagT"><span class="name type">TagT</span></a>&ensp;<span class="boundvar">m</span>)</code></dt>  <dt id="$resolved435"><code><span class="type resolved" title="Control.Monad.Trans.MonadTrans"><span class="name type">MonadTrans</span></span>&ensp;<a class="type" href="Tensor.html#Tensor.TagT"><span class="name type">TagT</span></a></code></dt></dl></dd><dt id="Tensor.Tag"><code><span class="keyword">0</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tag"><span class="name function">Tag</span></a>&ensp;:&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Tensor.Taggable"><code><span class="keyword">interface</span>&ensp;<a class="type" href="Tensor.html#Tensor.Taggable"><span class="name type">Taggable</span></a>&ensp;:&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd>  <b>Parameters</b>:&ensp;a<br><b>Methods</b>:<br><dl class="decls">  <dt id="Tensor.tag"><code><a class="type" href="Tensor.html#Tensor.tag"><span class="name function">tag</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Interfaces.Monad"><span class="name type">Monad</span></span>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.TagT"><span class="name type">TagT</span></a>&ensp;<span class="boundvar">m</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Mark an expression to be efficiently reused. For example, in<br>  ```<br>  bad : Tensor [9999999] F64<br>  bad = let x = fill {shape = [9999999]} 1.0 in x + x<br>  <br>  good : Tag $ Tensor [9999999] F64<br>  good = do x &lt;- tag $ fill {shape = [9999999]} 1.0<br>            pure (x + x)<br>  ```<br>  the large vector `x` is calculated twice in `bad`, but once in `good`, as `tag` marks it for<br>  sharing.<br>  <br>  Types that implement this interface should `tag` constituent components it deems worth sharing.<br>  For example, see the implementation for tuples.<br>  <br>  See tutorial [_Nuisances in the Tensor API_](https://github.com/joelberkeley/spidr/blob/master/tutorials/Nuisances.md) for details.</pre></dd></dl><br><b>Implementations</b>:<br><dl class="decls">  <dt id="$resolved11280"><code><a class="type" href="Tensor.html#Tensor.Taggable"><span class="name type">Taggable</span></a>&ensp;(<a class="type" href="Data.html#Data.Dataset"><span class="name type">Dataset</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">t</span>)</code></dt>  <dt id="$resolved11157"><code><a class="type" href="Tensor.html#Tensor.Taggable"><span class="name type">Taggable</span></a>&ensp;(<a class="type" href="Distribution.html#Distribution.Gaussian"><span class="name type">Gaussian</span></a>&ensp;<span class="boundvar">event</span>&ensp;<span class="boundvar">dim</span>)</code></dt>  <dt id="$resolved432"><code><a class="type" href="Tensor.html#Tensor.Taggable"><span class="name type">Taggable</span></a>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>)</code></dt>  <dt id="$resolved431"><code>(<a class="type" href="Tensor.html#Tensor.Taggable"><span class="name type">Taggable</span></a>&ensp;<span class="boundvar">a</span>,&ensp;<a class="type" href="Tensor.html#Tensor.Taggable"><span class="name type">Taggable</span></a>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Taggable"><span class="name type">Taggable</span></a>&ensp;(<span class="boundvar">a</span>,&ensp;<span class="boundvar">b</span>)</code></dt></dl></dd><dt id="Tensor.tag"><code><a class="type" href="Tensor.html#Tensor.tag"><span class="name function">tag</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Taggable"><span class="name type">Taggable</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.Monad"><span class="name type">Monad</span></span>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.TagT"><span class="name type">TagT</span></a>&ensp;<span class="boundvar">m</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Mark an expression to be efficiently reused. For example, in<br>  ```<br>  bad : Tensor [9999999] F64<br>  bad = let x = fill {shape = [9999999]} 1.0 in x + x<br>  <br>  good : Tag $ Tensor [9999999] F64<br>  good = do x &lt;- tag $ fill {shape = [9999999]} 1.0<br>            pure (x + x)<br>  ```<br>  the large vector `x` is calculated twice in `bad`, but once in `good`, as `tag` marks it for<br>  sharing.<br>  <br>  Types that implement this interface should `tag` constituent components it deems worth sharing.<br>  For example, see the implementation for tuples.<br>  <br>  See tutorial [_Nuisances in the Tensor API_](https://github.com/joelberkeley/spidr/blob/master/tutorials/Nuisances.md) for details.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Tensor.tensor"><code><a class="type" href="Tensor.html#Tensor.tensor"><span class="name function">tensor</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.PrimitiveRW"><span class="name type">PrimitiveRW</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Literal.html#Literal.Literal"><span class="name type">Literal</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Construct a `Tensor` from `Literal` data. For example<br>  ```<br>  x : Tensor [2, 3] S32<br>  x = tensor [[1, 2, 3],<br>              [4, 5, 6]]<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.F64.fromDouble"><code><span class="type resolved" title="Tensor.F64.fromDouble"><span class="name function">fromDouble</span></span>&ensp;:&ensp;<span class="name type">Double</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.S32.fromInteger"><code><span class="type resolved" title="Tensor.S32.fromInteger"><span class="name function">fromInteger</span></span>&ensp;:&ensp;<span class="name type">Integer</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.S32"><span class="name type">S32</span></a></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.Tag.eval"><code><span class="type resolved" title="Tensor.Tag.eval"><span class="name function">eval</span></span>&ensp;:&ensp;<a class="type" href="Device.html#Device.Device"><span class="name type">Device</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Primitive.html#Primitive.PrimitiveRW"><span class="name type">PrimitiveRW</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="boundvar">ty</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tag"><span class="name function">Tag</span></a>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="PrimIO.IO"><span class="name type">IO</span></span>&ensp;(<a class="type" href="Literal.html#Literal.Literal"><span class="name type">Literal</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">ty</span>)</code></dt><dd><pre>  Evaluate a `Tensor`, returning its value as a `Literal`. This function builds and executes the<br>  computational graph.<br>  <br>  **Note:** Each call to `eval` will rebuild and execute the graph; multiple calls to `eval` on<br>  different tensors, even if they are in the same computation, will be treated independently.<br>  To efficiently evaluate multiple tensors at once, use `TensorList.Tag.eval`.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.eval"><code><a class="type" href="Tensor.html#Tensor.eval"><span class="name function">eval</span></a>&ensp;:&ensp;<a class="type" href="Device.html#Device.Device"><span class="name type">Device</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Primitive.html#Primitive.PrimitiveRW"><span class="name type">PrimitiveRW</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="boundvar">ty</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="PrimIO.IO"><span class="name type">IO</span></span>&ensp;(<a class="type" href="Literal.html#Literal.Literal"><span class="name type">Literal</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">ty</span>)</code></dt><dd><pre>  A convenience wrapper for `Tag.eval`, for use with a bare `Tensor`.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.TensorList.Tag.TensorList"><code><span class="keyword">data</span>&ensp;<span class="type resolved" title="Tensor.TensorList.Tag.TensorList"><span class="name type">TensorList</span></span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<a class="type" href="Types.html#Types.Shape"><span class="name function">Shape</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A list of `Tensor`s, along with the conversions needed to evaluate them to `Literal`s.<br>  The list is parametrized by the shapes and types of the resulting `Literal`s.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructors</b>:<br><dl class="decls">  <dt id="Tensor.TensorList.Tag.Nil"><code><span class="type resolved" title="Tensor.TensorList.Tag.Nil"><span class="name constructor">Nil</span></span>&ensp;:&ensp;<span class="type resolved" title="Tensor.TensorList.Tag.TensorList"><span class="name type">TensorList</span></span>&ensp;[]&ensp;[]</code></dt>  <dt id="Tensor.TensorList.Tag.(::)"><code><span class="type resolved" title="Tensor.TensorList.Tag.(::)"><span class="name constructor">(::)</span></span>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.PrimitiveRW"><span class="name type">PrimitiveRW</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="boundvar">ty</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Tensor.TensorList.Tag.TensorList"><span class="name type">TensorList</span></span>&ensp;<span class="boundvar">shapes</span>&ensp;<span class="boundvar">tys</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Tensor.TensorList.Tag.TensorList"><span class="name type">TensorList</span></span>&ensp;(<span class="boundvar">shape</span>&ensp;<span class="type resolved" title="Prelude.Basics.(::)"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">shapes</span>)&ensp;(<span class="boundvar">ty</span>&ensp;<span class="type resolved" title="Prelude.Basics.(::)"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">tys</span>)</code></dt></dl></dd><dt id="Tensor.TensorList.Tag.eval"><code><span class="type resolved" title="Tensor.TensorList.Tag.eval"><span class="name function">eval</span></span>&ensp;:&ensp;<a class="type" href="Device.html#Device.Device"><span class="name type">Device</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tag"><span class="name function">Tag</span></a>&ensp;(<span class="type resolved" title="Tensor.TensorList.Tag.TensorList"><span class="name type">TensorList</span></span>&ensp;<span class="boundvar">shapes</span>&ensp;<span class="boundvar">tys</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="PrimIO.IO"><span class="name type">IO</span></span>&ensp;(<span class="type resolved" title="Util.List.All2.All2"><span class="name type">All2</span></span>&ensp;<a class="type" href="Literal.html#Literal.Literal"><span class="name type">Literal</span></a>&ensp;<span class="boundvar">shapes</span>&ensp;<span class="boundvar">tys</span>)</code></dt><dd><pre>  Evaluate a list of `Tensor`s as a list of `Literal`s. Tensors in the list can have different<br>  shapes and element types. For example,<br>  ```<br>  main : Device -&gt; IO ()<br>  main device = do [x, y] &lt;- eval device $ do let x = tensor {dtype = F64} [1.2, 3.4]<br>                                              y &lt;- reduce @{Sum} [0] x<br>                                              pure [x, y]<br>                   printLn x<br>                   printLn y<br>  ```<br>  In contrast to `Tensor.eval` when called on multiple tensors, this function constructs and<br>  compiles the graph just once.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.TensorList.eval"><code><span class="type resolved" title="Tensor.TensorList.eval"><span class="name function">eval</span></span>&ensp;:&ensp;<a class="type" href="Device.html#Device.Device"><span class="name type">Device</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Tensor.TensorList.Tag.TensorList"><span class="name type">TensorList</span></span>&ensp;<span class="boundvar">shapes</span>&ensp;<span class="boundvar">tys</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="PrimIO.IO"><span class="name type">IO</span></span>&ensp;(<span class="type resolved" title="Util.List.All2.All2"><span class="name type">All2</span></span>&ensp;<a class="type" href="Literal.html#Literal.Literal"><span class="name type">Literal</span></a>&ensp;<span class="boundvar">shapes</span>&ensp;<span class="boundvar">tys</span>)</code></dt><dd><pre>  A convenience wrapper for `TensorList.Tag.eval`, for use with a bare `TensorList`.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.castDtype"><code><a class="type" href="Tensor.html#Tensor.castDtype"><span class="name function">castDtype</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Integral"><span class="name type">Integral</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  Cast the element type. For example, `castDtype (tensor {dtype = S32} [1, -2])` is<br>  `tensor {dtype = F64} [1.0, -2.0]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.reshape"><code><a class="type" href="Tensor.html#Tensor.reshape"><span class="name function">reshape</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Interfaces.product"><span class="name function">product</span></span>&ensp;<span class="boundvar">from</span>&ensp;<span class="keyword">=</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.product"><span class="name function">product</span></span>&ensp;<span class="boundvar">to</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">from</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">to</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Reshape a `Tensor`. For example, `reshape {to = [2, 1]} (tensor [3, 4])` is<br>  `tensor [[3], [4]]`. The output can have a different rank to the input.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.expand"><code><a class="type" href="Tensor.html#Tensor.expand"><span class="name function">expand</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">axis</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">inBounds</span>&ensp;:&ensp;<span class="type resolved" title="Data.Nat.LTE"><span class="name type">LTE</span></span>&ensp;<span class="boundvar">axis</span>&ensp;(<span class="type resolved" title="Prelude.Types.List.length"><span class="name function">length</span></span>&ensp;<span class="boundvar">shape</span>)}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="type resolved" title="Data.List.insertAt"><span class="name function">insertAt</span></span>&ensp;<span class="boundvar">axis</span>&ensp;<span class="name constructor">1</span>&ensp;<span class="boundvar">shape</span>)&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Add a dimension of length one at the specified `axis`. The new dimension will be at the<br>  specified `axis` in the new `Tensor` (as opposed to the original `Tensor`). For example,<br>  `expand 1 $ tensor [[1, 2], [3, 4], [5, 6]]` is `tensor [[[1, 2]], [[3, 4]], [[5, 6]]]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.Squeezable.Squeezable"><code><span class="keyword">data</span>&ensp;<span class="type resolved" title="Tensor.Squeezable.Squeezable"><span class="name type">Squeezable</span></span>&ensp;:&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<a class="type" href="Types.html#Types.Shape"><span class="name function">Shape</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<a class="type" href="Types.html#Types.Shape"><span class="name function">Shape</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A `Squeezable from to` constitutes proof that the shape `from` can be squeezed to the<br>  shape `to`. Squeezing is the process of removing any number of dimensions of length one.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructors</b>:<br><dl class="decls">  <dt id="Tensor.Squeezable.Same"><code><span class="type resolved" title="Tensor.Squeezable.Same"><span class="name constructor">Same</span></span>&ensp;:&ensp;<span class="type resolved" title="Tensor.Squeezable.Squeezable"><span class="name type">Squeezable</span></span>&ensp;<span class="boundvar">x</span>&ensp;<span class="boundvar">x</span></code></dt><dd><pre>  Proof that a shape can be squeezed to itself. For example:<br>  <br>  [] to []<br>  [3, 4] to [3, 4]</pre></dd>  <dt id="Tensor.Squeezable.Match"><code><span class="type resolved" title="Tensor.Squeezable.Match"><span class="name constructor">Match</span></span>&ensp;:&ensp;<span class="type resolved" title="Tensor.Squeezable.Squeezable"><span class="name type">Squeezable</span></span>&ensp;<span class="boundvar">from</span>&ensp;<span class="boundvar">to</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Tensor.Squeezable.Squeezable"><span class="name type">Squeezable</span></span>&ensp;(<span class="boundvar">x</span>&ensp;<span class="type resolved" title="Prelude.Basics.(::)"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">from</span>)&ensp;(<span class="boundvar">x</span>&ensp;<span class="type resolved" title="Prelude.Basics.(::)"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">to</span>)</code></dt><dd><pre>  Proof that any dimensions (including those of length 1) can be preserved in the process of<br>  squeezing. For example:<br>  <br>  ...</pre></dd>  <dt id="Tensor.Squeezable.Nest"><code><span class="type resolved" title="Tensor.Squeezable.Nest"><span class="name constructor">Nest</span></span>&ensp;:&ensp;<span class="type resolved" title="Tensor.Squeezable.Squeezable"><span class="name type">Squeezable</span></span>&ensp;<span class="boundvar">from</span>&ensp;<span class="boundvar">to</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Tensor.Squeezable.Squeezable"><span class="name type">Squeezable</span></span>&ensp;(<span class="name constructor">1</span>&ensp;<span class="type resolved" title="Prelude.Basics.(::)"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">from</span>)&ensp;<span class="boundvar">to</span></code></dt><dd><pre>  Proof that any dimensions of length one can be squeezed out. For example:<br>  <br>  [1, 3, 1, 1, 4] to [3, 4]</pre></dd></dl></dd><dt id="Tensor.squeeze"><code><a class="type" href="Tensor.html#Tensor.squeeze"><span class="name function">squeeze</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Tensor.Squeezable.Squeezable"><span class="name type">Squeezable</span></span>&ensp;<span class="boundvar">from</span>&ensp;<span class="boundvar">to</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">from</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">to</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Remove dimensions of length one from a `Tensor` such that it has the desired shape. For example:<br>  <br>  ```<br>  x : Tensor [2, 1, 3, 1] S32<br>  x = tensor [[[[4], [5], [6]]],<br>              [[[7], [8], [9]]]]<br>  <br>  y : Tensor [2, 1, 3] S32<br>  y = squeeze x<br>  ```<br>  is<br>  ```<br>  y : Tensor [2, 1, 3] S32<br>  y = tensor [[[4, 5, 6]],<br>              [[7, 8, 9]]]<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.SliceOrIndex"><code><span class="keyword">data</span>&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A `SliceOrIndex d` is a valid slice or index into a dimension of size `d`. See `slice` for<br>  details.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Constructors</b>:<br><dl class="decls">  <dt id="Tensor.Slice"><code><a class="type" href="Tensor.html#Tensor.Slice"><span class="name constructor">Slice</span></a>&ensp;:&ensp;(<span class="boundvar">from</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">to</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="boundvar">from</span>&ensp;<span class="type resolved" title="Prelude.Num.(+)"><span class="name function">+</span></span>&ensp;<span class="boundvar">size</span>&ensp;<span class="keyword">=</span>&ensp;<span class="boundvar">to</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.Nat.LTE"><span class="name type">LTE</span></span>&ensp;<span class="boundvar">to</span>&ensp;<span class="boundvar">d</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;<span class="boundvar">d</span></code></dt>  <dt id="Tensor.Index"><code><a class="type" href="Tensor.html#Tensor.Index"><span class="name constructor">Index</span></a>&ensp;:&ensp;(<span class="boundvar">idx</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.Nat.LT"><span class="name function">LT</span></span>&ensp;<span class="boundvar">idx</span>&ensp;<span class="boundvar">d</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;<span class="boundvar">d</span></code></dt>  <dt id="Tensor.DynamicSlice"><code><a class="type" href="Tensor.html#Tensor.DynamicSlice"><span class="name constructor">DynamicSlice</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.U64"><span class="name type">U64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">size</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.Nat.LTE"><span class="name type">LTE</span></span>&ensp;<span class="boundvar">size</span>&ensp;<span class="boundvar">d</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;<span class="boundvar">d</span></code></dt>  <dt id="Tensor.DynamicIndex"><code><a class="type" href="Tensor.html#Tensor.DynamicIndex"><span class="name constructor">DynamicIndex</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.U64"><span class="name type">U64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;<span class="boundvar">d</span></code></dt></dl></dd><dt id="Tensor.at"><code><a class="type" href="Tensor.html#Tensor.at"><span class="name function">at</span></a>&ensp;:&ensp;(<span class="boundvar">idx</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.Nat.LT"><span class="name function">LT</span></span>&ensp;<span class="boundvar">idx</span>&ensp;<span class="boundvar">d</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;<span class="boundvar">d</span></code></dt><dd><pre>  Index at `idx`. See `slice` for details.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Tensor.Dynamic.at"><code><span class="type resolved" title="Tensor.Dynamic.at"><span class="name function">at</span></span>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.U64"><span class="name type">U64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;<span class="boundvar">d</span></code></dt><dd><pre>  Index at the specified index. See `slice` for details.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Tensor.(.to)"><code><a class="type" href="Tensor.html#Tensor.(.to)"><span class="name function">.to</span></a>&ensp;:&ensp;(<span class="boundvar">from</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">to</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="boundvar">from</span>&ensp;<span class="type resolved" title="Prelude.Num.(+)"><span class="name function">+</span></span>&ensp;<span class="boundvar">size</span>&ensp;<span class="keyword">=</span>&ensp;<span class="boundvar">to</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.Nat.LTE"><span class="name type">LTE</span></span>&ensp;<span class="boundvar">to</span>&ensp;<span class="boundvar">d</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;<span class="boundvar">d</span></code></dt><dd><pre>  Slice from `from` (inclusive) to `to` (exclusive). See `slice` for details.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Tensor.(.size)"><code><a class="type" href="Tensor.html#Tensor.(.size)"><span class="name function">.size</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.U64"><span class="name type">U64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">size</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.Nat.LTE"><span class="name type">LTE</span></span>&ensp;<span class="boundvar">size</span>&ensp;<span class="boundvar">d</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;<span class="boundvar">d</span></code></dt><dd><pre>  Slice `size` elements starting at the specified scalar `U64` index. See `slice` for details.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Tensor.all"><code><a class="type" href="Tensor.html#Tensor.all"><span class="name function">all</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;<span class="boundvar">d</span></code></dt><dd><pre>  Slice across all indices along an axis. See `slice` for details.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Tensor.MultiSlice"><code><span class="keyword">data</span>&ensp;<a class="type" href="Tensor.html#Tensor.MultiSlice"><span class="name type">MultiSlice</span></a>&ensp;:&ensp;<a class="type" href="Types.html#Types.Shape"><span class="name function">Shape</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A `MultiSlice shape` is a valid multi-dimensional slice into a tensor with shape `shape`.<br>  See `slice` for details.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructors</b>:<br><dl class="decls">  <dt id="Tensor.Nil"><code><a class="type" href="Tensor.html#Tensor.Nil"><span class="name constructor">Nil</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.MultiSlice"><span class="name type">MultiSlice</span></a>&ensp;<span class="boundvar">ds</span></code></dt>  <dt id="Tensor.(::)"><code><a class="type" href="Tensor.html#Tensor.(::)"><span class="name constructor">(::)</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;<span class="boundvar">d</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.MultiSlice"><span class="name type">MultiSlice</span></a>&ensp;<span class="boundvar">ds</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.MultiSlice"><span class="name type">MultiSlice</span></a>&ensp;(<span class="boundvar">d</span>&ensp;<span class="type resolved" title="Prelude.Basics.(::)"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">ds</span>)</code></dt></dl></dd><dt id="Tensor.MultiSlice.slice"><code><span class="type resolved" title="Tensor.MultiSlice.slice"><span class="name function">slice</span></span>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.MultiSlice"><span class="name type">MultiSlice</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Types.html#Types.Shape"><span class="name function">Shape</span></a></code></dt><dd><pre>  The shape of a tensor produced by slicing with the specified multi-dimensional slice. See<br>  `Tensor.slice` for details.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Tensor.slice"><code><a class="type" href="Tensor.html#Tensor.slice"><span class="name function">slice</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">at</span>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.MultiSlice"><span class="name type">MultiSlice</span></a>&ensp;<span class="boundvar">shape</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="type resolved" title="Tensor.MultiSlice.slice"><span class="name function">slice</span></span>&ensp;<span class="boundvar">at</span>)&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Slice or index `Tensor` axes. Each axis can be sliced or indexed, and this can be done with<br>  either static (`Nat`) or dynamic (scalar `U64`) indices.<br>  <br>  **Static indices**<br>  <br>  Static indices are `Nat`s. For example, for<br>  ```<br>  x : Tensor [5, 6] S32<br>  x = tensor [[ 0,  1,  2,  3,  4,  5],<br>              [ 6,  7,  8,  9, 10, 11],<br>              [12, 13, 14, 15, 16, 17],<br>              [18, 19, 20, 21, 22, 23],<br>              [24, 25, 26, 27, 28, 29]]<br>  ```<br>  we can index as `slice [at 1] x` to get<br>  ```<br>  x : Tensor [6] S32<br>  x = tensor [6, 7, 8, 9, 10, 11]<br>  ```<br>  or we can slice as `slice [2.to 4] x` to get<br>  ```<br>  x : Tensor [2, 6] S32<br>  x = tensor [[12, 13, 14, 15, 16, 17],<br>              [18, 19, 20, 21, 22, 23]]<br>  ```<br>  Note that in `2.to 4`, the 2 is inclusive, and the 4 exclusive, so we return indices 2 and 3.<br>  <br>  **Dynamic indices**<br>  <br>  Dynamic indices are scalar `U64` values, and the API works slightly differently because we<br>  can&apos;t know the value of dynamic indices until the graph is executed. For indexing, with scalar<br>  `U64` index `i` in `slice [at i] x`, `i` is clamped to be a valid index into that dimension.<br>  For example, for `i = tensor 1`, `slice [at i] x` is<br>  ```<br>  x : Tensor [6] S32<br>  x = tensor [6, 7, 8, 9, 10, 11]<br>  ```<br>  as in the static case. However, for `i = tensor 10`, `slice [at i] x` returns the last row<br>  ```<br>  x : Tensor [6] S32<br>  x = tensor [24, 25, 26, 27, 28, 29]<br>  ```<br>  We can also slice by specifying a scalar `U64` start index, and a static size, as<br>  `slice [i.size 2] x` with `i = tensor 2` to get<br>  ```<br>  x : Tensor [2, 6] S32<br>  x = tensor [[12, 13, 14, 15, 16, 17],<br>              [18, 19, 20, 21, 22, 23]]<br>  ```<br>  For a given slice `size`, the dynamic start index is clamped such that we always get `size`<br>  elements along that axis. For example, `slice [i.size 2] x` with `i = tensor 4` is<br>  ```<br>  x : Tensor [2, 6] S32<br>  x = tensor [[18, 19, 20, 21, 22, 23],<br>              [24, 25, 26, 27, 28, 29]]<br>  ```<br>  which starts at index 3 rather than index 4.<br>  <br>  **Mixed static, dynamic, slicing and indexing**<br>  <br>  Each axis can only be sliced or indexed, and must use only static or dynamic indices. However,<br>  across axes, we can mix these four arbitrarily. For example, with `slice [2.to 4, at 1] x` to<br>  get<br>  ```<br>  x : Tensor [2] S32<br>  x = tensor [13, 19]<br>  ```<br>  or with `i = tensor 2` in `slice [at 1, i.size 2] x` to get<br>  ```<br>  x : Tensor [2] S32<br>  x = tensor [7, 8]<br>  ```<br>  <br>  Slices and indices apply to the leading axes of the tensor. For trailing axes omitted from the<br>  multi-dimensional slice, the whole of the axis is returned. If we want to slice or index over<br>  later axes and retain all indices in a leading axis, we can use the convenience function `all`,<br>  as `slice [all, at 3] x` to get<br>  ```<br>  x : Tensor [5] S32<br>  x = tensor [[3], [9], [15], [21], [27]]<br>  ```<br>  This is exactly the same as the more manual `slice [0.to 5, at 3] x` and<br>  `slice [(tensor 0).size 5, at 3] x`.<br>  <br>  @at The multi-dimensional slices and indices at which to slice the tensor.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.concat"><code><a class="type" href="Tensor.html#Tensor.concat"><span class="name function">concat</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">axis</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">s</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">s&apos;</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">inBounds</span>&ensp;:&ensp;(<span class="type resolved" title="Data.List.InBounds"><span class="name type">InBounds</span></span>&ensp;<span class="boundvar">axis</span>&ensp;<span class="boundvar">s</span>,&ensp;<span class="type resolved" title="Data.List.InBounds"><span class="name type">InBounds</span></span>&ensp;<span class="boundvar">axis</span>&ensp;<span class="boundvar">s&apos;</span>)}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.List.deleteAt"><span class="name function">deleteAt</span></span>&ensp;<span class="boundvar">axis</span>&ensp;<span class="boundvar">s</span>&ensp;<span class="keyword">=</span>&ensp;<span class="type resolved" title="Data.List.deleteAt"><span class="name function">deleteAt</span></span>&ensp;<span class="boundvar">axis</span>&ensp;<span class="boundvar">s&apos;</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="type resolved" title="Data.List.replaceAt"><span class="name function">replaceAt</span></span>&ensp;<span class="boundvar">axis</span>&ensp;(<span class="type resolved" title="Data.List.index"><span class="name function">index</span></span>&ensp;<span class="boundvar">axis</span>&ensp;<span class="boundvar">s</span>&ensp;<span class="type resolved" title="Prelude.Num.(+)"><span class="name function">+</span></span>&ensp;<span class="type resolved" title="Data.List.index"><span class="name function">index</span></span>&ensp;<span class="boundvar">axis</span>&ensp;<span class="boundvar">s&apos;</span>)&ensp;<span class="boundvar">s</span>)&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Concatenate two `Tensor`s along the specfied `axis`. For example,<br>  `concat 0 (tensor [[1, 2], [3, 4]]) (tensor [[5, 6]])` and<br>  `concat 1 (tensor [[3], [6]]) (tensor [[4, 5], [7, 8]])` are both<br>  `tensor [[1, 2], [3, 4], [5, 6]]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.diag"><code><a class="type" href="Tensor.html#Tensor.diag"><span class="name function">diag</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">n</span>,&ensp;<span class="boundvar">n</span>]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">n</span>]&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  The diagonal of a matrix as a vector. For example, for<br>  ```<br>  x : Tensor [3, 3] S32<br>  x = tensor [[0, 1, 2],<br>              [3, 4, 5],<br>              [6, 7, 8]]<br>  ```<br>  `diag x` is `tensor [0, 4, 8]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.Triangle"><code><span class="keyword">data</span>&ensp;<a class="type" href="Tensor.html#Tensor.Triangle"><span class="name type">Triangle</span></a>&ensp;:&ensp;<span class="name type">Type</span></code></dt><dd><pre>  Represents the upper- or lower-triangular component of a matrix.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructors</b>:<br><dl class="decls">  <dt id="Tensor.Upper"><code><a class="type" href="Tensor.html#Tensor.Upper"><span class="name constructor">Upper</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Triangle"><span class="name type">Triangle</span></a></code></dt>  <dt id="Tensor.Lower"><code><a class="type" href="Tensor.html#Tensor.Lower"><span class="name constructor">Lower</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Triangle"><span class="name type">Triangle</span></a></code></dt></dl></dd><dt id="Tensor.triangle"><code><a class="type" href="Tensor.html#Tensor.triangle"><span class="name function">triangle</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Triangle"><span class="name type">Triangle</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">n</span>,&ensp;<span class="boundvar">n</span>]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">n</span>,&ensp;<span class="boundvar">n</span>]&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Get the upper- or lower-triangular component of a matrix. For example, for<br>  ```<br>  x : Tensor [3, 3] S32<br>  x = tensor [[1, 2, 3],<br>              [4, 5, 6],<br>              [7, 8, 9]]<br>  ```<br>  `triangle Lower x` is<br>  ```<br>  x : Tensor [3, 3] S32<br>  x = tensor [[1, 0, 0],<br>              [4, 5, 0],<br>              [7, 8, 9]]<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.(.T)"><code><a class="type" href="Tensor.html#Tensor.(.T)"><span class="name function">.T</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>,&ensp;<span class="boundvar">n</span>]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">n</span>,&ensp;<span class="boundvar">m</span>]&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Transpose a matrix. For example, `(tensor [[1, 2], [3, 4]]).T` is `tensor [[1, 3], [2, 4]]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.transpose"><code><a class="type" href="Tensor.html#Tensor.transpose"><span class="name function">transpose</span></a>&ensp;:&ensp;(<span class="boundvar">ordering</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.List.length"><span class="name function">length</span></span>&ensp;<span class="boundvar">ordering</span>&ensp;<span class="keyword">=</span>&ensp;<span class="type resolved" title="Prelude.Types.List.length"><span class="name function">length</span></span>&ensp;<span class="boundvar">shape</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Util.List.unique"><span class="name function">unique</span></span>&ensp;<span class="boundvar">ordering</span>&ensp;<span class="keyword">=</span>&ensp;<span class="type resolved" title="Prelude.Basics.True"><span class="name constructor">True</span></span>}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">inBounds</span>&ensp;:&ensp;<span class="type resolved" title="Data.List.Quantifiers.All.All"><span class="name type">All</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.flip"><span class="name function">flip</span></span>&ensp;<span class="type resolved" title="Data.List.InBounds"><span class="name type">InBounds</span></span>&ensp;<span class="boundvar">shape</span>)&ensp;<span class="boundvar">ordering</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="type resolved" title="Util.List.multiIndex"><span class="name function">multiIndex</span></span>&ensp;<span class="boundvar">ordering</span>&ensp;<span class="boundvar">shape</span>)&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Transpose axes of a tensor. This is a more general version of `(.T)`, in which you can<br>  transpose any number of axes in a tensor of arbitrary rank. The i&apos;th axis in the resulting<br>  tensor corresponds to the `index i ordering`&apos;th axis in the input tensor. For example, for<br>  ```<br>  x : Tensor [2, 3, 4] S32<br>  x = tensor [[[ 0,  1,  2,  3],<br>               [ 4,  5,  6,  7],<br>               [ 8,  9, 10, 11]],<br>              [[12, 13, 14, 15],<br>               [16, 17, 18, 19],<br>               [20, 21, 22, 23]]]<br>  ```<br>  `transpose [0, 2, 1] x` is<br>  ```<br>  x : Tensor [2, 4, 3] S32<br>  x = tensor [[[ 0,  4,  8],<br>               [ 1,  5,  9],<br>               [ 2,  6, 10],<br>               [ 3,  7, 11]],<br>              [[12, 16, 20],<br>               [13, 17, 21],<br>               [14, 18, 22],<br>               [15, 19, 23]]]<br>  ```<br>  `transpose [2, 0, 1] x` is<br>  ```<br>  x : Tensor [4, 2, 3] S32<br>  x = tensor [[[ 0,  4,  8],<br>               [12, 16, 20]],<br>              [[ 1,  5,  9],<br>               [13, 17, 21]],<br>              [[ 2,  6, 10],<br>               [14, 18, 22]],<br>              [[ 3,  7, 11],<br>               [15, 19, 23]]]<br>  ```<br>  <br>  In order to see what effect transposing a tensor has, it can help to bear in mind the following:<br>  * if an element can be found with `slice [at 3, at 4, at 5] x` in the original tensor,<br>    that same element can instead be found with `slice [at 5, at 3, at 4]` given a<br>    `transpose [2, 0, 1]`. That is, transposing axes re-orders indices when indexing.<br>  * with `transpose [2, 0, 1]`, traversing the first axis in the result is equivalent to<br>    traversing the last axis in the input. Similarly, traversing the last axis in the result is<br>    equivalent to traversing the second axis in the input.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.identity"><code><a class="type" href="Tensor.html#Tensor.identity"><span class="name function">identity</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Num"><span class="name type">Num</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">n</span>,&ensp;<span class="boundvar">n</span>]&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  The identity tensor, with inferred shape and element type. For example,<br>  ```<br>  x : Tensor [2, 2] S32<br>  x = identity<br>  ```<br>  is<br>  ```<br>  x : Tensor [2, 2] S32<br>  x = tensor [[1, 0],<br>              [0, 1]]<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.DimBroadcastable"><code><span class="keyword">data</span>&ensp;<a class="type" href="Tensor.html#Tensor.DimBroadcastable"><span class="name type">DimBroadcastable</span></a>&ensp;:&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A `DimBroadcastable from to` proves that a dimension of size `from` can be broadcast to a<br>  dimension of size `to`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructors</b>:<br><dl class="decls">  <dt id="Tensor.Same"><code><a class="type" href="Tensor.html#Tensor.Same"><span class="name constructor">Same</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.DimBroadcastable"><span class="name type">DimBroadcastable</span></a>&ensp;<span class="boundvar">x</span>&ensp;<span class="boundvar">x</span></code></dt><dd><pre>  Proof that any dimension can be broadcast to itself. For example in shapes `[2, 3]` to<br>  `[2, 3]`.</pre></dd>  <dt id="Tensor.Stack"><code><a class="type" href="Tensor.html#Tensor.Stack"><span class="name constructor">Stack</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.DimBroadcastable"><span class="name type">DimBroadcastable</span></a>&ensp;<span class="name constructor">1</span>&ensp;<span class="boundvar">{_:4554}</span></code></dt><dd><pre>  Proof that a dimension of length one can be broadcast to any size. For example in shapes<br>  `[2, 1]` to `[2, 3]`</pre></dd>  <dt id="Tensor.Zero"><code><a class="type" href="Tensor.html#Tensor.Zero"><span class="name constructor">Zero</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.DimBroadcastable"><span class="name type">DimBroadcastable</span></a>&ensp;<span class="boundvar">{_:4560}</span>&ensp;<span class="name constructor">0</span></code></dt><dd><pre>  Proof that any dimension can be broadcast to zero. For example in shapes `[2, 3]` to `[2, 0]`.</pre></dd></dl></dd><dt id="Tensor.Broadcastable.Broadcastable"><code><span class="keyword">data</span>&ensp;<span class="type resolved" title="Tensor.Broadcastable.Broadcastable"><span class="name type">Broadcastable</span></span>&ensp;:&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<a class="type" href="Types.html#Types.Shape"><span class="name function">Shape</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<a class="type" href="Types.html#Types.Shape"><span class="name function">Shape</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A `Broadcastable from to` constitutes proof that the shape `from` can be broadcast to the<br>  shape `to`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructors</b>:<br><dl class="decls">  <dt id="Tensor.Broadcastable.Same"><code><span class="type resolved" title="Tensor.Broadcastable.Same"><span class="name constructor">Same</span></span>&ensp;:&ensp;<span class="type resolved" title="Tensor.Broadcastable.Broadcastable"><span class="name type">Broadcastable</span></span>&ensp;<span class="boundvar">x</span>&ensp;<span class="boundvar">x</span></code></dt><dd><pre>  Proof that a shape can be broadcast to itself. For example:<br>  <br>  [] to []<br>  [3, 4] to [3, 4]<br>  <br>  Implementation note: we could have used `Broadcast [] []`, which would have resulted in more<br>  atomic constructors for `Broadcastable`, but the author guesses that this implementation helps<br>  the type checker avoid applications of `Match`.</pre></dd>  <dt id="Tensor.Broadcastable.Match"><code><span class="type resolved" title="Tensor.Broadcastable.Match"><span class="name constructor">Match</span></span>&ensp;:&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.List.length"><span class="name function">length</span></span>&ensp;<span class="boundvar">from</span>&ensp;<span class="keyword">=</span>&ensp;<span class="type resolved" title="Prelude.Types.List.length"><span class="name function">length</span></span>&ensp;<span class="boundvar">to</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.DimBroadcastable"><span class="name type">DimBroadcastable</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">t</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Tensor.Broadcastable.Broadcastable"><span class="name type">Broadcastable</span></span>&ensp;<span class="boundvar">from</span>&ensp;<span class="boundvar">to</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Tensor.Broadcastable.Broadcastable"><span class="name type">Broadcastable</span></span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="type resolved" title="Prelude.Basics.(::)"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">from</span>)&ensp;(<span class="boundvar">t</span>&ensp;<span class="type resolved" title="Prelude.Basics.(::)"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">to</span>)</code></dt><dd><pre>  Proof that a dimension of size `f` can be broadcast to size `t` if these dimensions<br>  are `DimBroadcastable f t`. For example:<br>  <br>  [2, 3] to [2, 3]<br>  [2, 1] to [2, 3]<br>  [2, 1] to [2, 0]</pre></dd>  <dt id="Tensor.Broadcastable.Nest"><code><span class="type resolved" title="Tensor.Broadcastable.Nest"><span class="name constructor">Nest</span></span>&ensp;:&ensp;<span class="type resolved" title="Tensor.Broadcastable.Broadcastable"><span class="name type">Broadcastable</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Tensor.Broadcastable.Broadcastable"><span class="name type">Broadcastable</span></span>&ensp;<span class="boundvar">f</span>&ensp;(<span class="boundvar">{_:4611}</span>&ensp;<span class="type resolved" title="Prelude.Basics.(::)"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">t</span>)</code></dt><dd><pre>  Proof that broadcasting can add outer dimensions i.e. nesting. For example:<br>  <br>  [3] to [1, 3]<br>  [3] to [5, 3]</pre></dd></dl><br>  <b>Hint</b>:&ensp;<dl class="decls"><dt id="$resolved744"><code>(<span class="boundvar">to</span>&ensp;:&ensp;<a class="type" href="Types.html#Types.Shape"><span class="name function">Shape</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Tensor.Broadcastable.Broadcastable"><span class="name type">Broadcastable</span></span>&ensp;[]&ensp;<span class="boundvar">to</span></code></dt></dl></dd><dt id="Tensor.broadcastableByLeading"><code><a class="type" href="Tensor.html#Tensor.broadcastableByLeading"><span class="name function">broadcastableByLeading</span></a>&ensp;:&ensp;(<span class="boundvar">leading</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Tensor.Broadcastable.Broadcastable"><span class="name type">Broadcastable</span></span>&ensp;<span class="boundvar">shape</span>&ensp;(<span class="boundvar">leading</span>&ensp;<span class="type resolved" title="Prelude.Types.List.(++)"><span class="name function">++</span></span>&ensp;<span class="boundvar">shape</span>)</code></dt><dd><pre>  A shape can be extended with any number of leading dimensions.<br>  <br>  @leading The leading dimensions.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.scalarToAnyOk"><code><a class="type" href="Tensor.html#Tensor.scalarToAnyOk"><span class="name function">scalarToAnyOk</span></a>&ensp;:&ensp;(<span class="boundvar">to</span>&ensp;:&ensp;<a class="type" href="Types.html#Types.Shape"><span class="name function">Shape</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Tensor.Broadcastable.Broadcastable"><span class="name type">Broadcastable</span></span>&ensp;[]&ensp;<span class="boundvar">to</span></code></dt><dd><pre>  A scalar can be broadcast to any shape.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.broadcast"><code><a class="type" href="Tensor.html#Tensor.broadcast"><span class="name function">broadcast</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Tensor.Broadcastable.Broadcastable"><span class="name type">Broadcastable</span></span>&ensp;<span class="boundvar">from</span>&ensp;<span class="boundvar">to</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">from</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">to</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Broadcast a `Tensor` to a new compatible shape. For example,<br>  ```<br>  x : Tensor [2, 3] S32<br>  x = broadcast (tensor [4, 5, 6])<br>  ```<br>  is<br>  ```<br>  x : Tensor [2, 3] S32<br>  x = tensor [[4, 5, 6], [4, 5, 6]]<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.fill"><code><a class="type" href="Tensor.html#Tensor.fill"><span class="name function">fill</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.PrimitiveRW"><span class="name type">PrimitiveRW</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="boundvar">ty</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">ty</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  A `Tensor` where every element has the specified value. For example,<br>  ```<br>  fives : Tensor [2, 3] S32<br>  fives = fill 5<br>  ```<br>  is<br>  ```<br>  fives : Tensor [2, 3] S32<br>  fives = tensor [[5, 5, 5],<br>                  [5, 5, 5]]<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.iota"><code><a class="type" href="Tensor.html#Tensor.iota"><span class="name function">iota</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Num"><span class="name type">Num</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">axis</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.List.InBounds"><span class="name type">InBounds</span></span>&ensp;<span class="boundvar">axis</span>&ensp;<span class="boundvar">shape</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  A constant where values increment from zero along the specified `axis`. For example,<br>  ```<br>  x : Tensor [3, 5] S32<br>  x = iota 1<br>  ```<br>  is the same as<br>  ```<br>  x : Tensor [3, 5] S32<br>  x = tensor [[0, 1, 2, 3, 4],<br>              [0, 1, 2, 3, 4],<br>              [0, 1, 2, 3, 4]]<br>  ```<br>  and<br>  ```<br>  x : Tensor [3, 5] S32<br>  x = iota 0<br>  ```<br>  is the same as<br>  ```<br>  x : Tensor [3, 5] S32<br>  x = tensor [[0, 0, 0, 0, 0],<br>              [1, 1, 1, 1, 1],<br>              [2, 2, 2, 2, 2]]<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.map"><code><a class="type" href="Tensor.html#Tensor.map"><span class="name function">map</span></a>&ensp;:&ensp;(<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">a</span>,&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">=&gt;</span>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tag"><span class="name function">Tag</span></a>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">b</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tag"><span class="name function">Tag</span></a>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">b</span>)</code></dt><dd><pre>  Lift a unary function on scalars to an element-wise function on `Tensor`s of arbitrary shape.<br>  For example,<br>  ```<br>  recip : Tensor [] F64 -&gt; Tag $ Tensor [] F64<br>  recip x = pure $ 1.0 / x<br>  ```<br>  can be lifted to an element-wise reciprocal function as `map recip (tensor [-2, 0.4])`,<br>  which produces `tensor [-0.5, 2.5]`.<br>  <br>  **Note:** Values tagged in the same scope as `map` cannot then be used within the scalar<br>  function passed to `map`. This is due to an [issue in XLA](https://github.com/openxla/xla/issues/14299).</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.map2"><code><a class="type" href="Tensor.html#Tensor.map2"><span class="name function">map2</span></a>&ensp;:&ensp;(<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">a</span>,&ensp;(<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">b</span>,&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">c</span>))&ensp;<span class="keyword">=&gt;</span>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tag"><span class="name function">Tag</span></a>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">c</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tag"><span class="name function">Tag</span></a>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">c</span>)</code></dt><dd><pre>  Lift a binary function on scalars to an element-wise function on `Tensor`s of arbitrary shape.<br>  For example,<br>  ```<br>  addRecip : Tensor [] F64 -&gt; Tensor [] F64 -&gt; Tag $ Tensor [] F64<br>  addRecip x y = pure $ x + 1.0 / y<br>  ```<br>  can be lifted to an element-wise function as<br>  `map2 addRecip (tensor [3.0, -3.0]) (tensor [-2.0, 0.4])`, which produces `tensor [2.5, -0.5]`.<br>  <br>  **Note:** Values tagged in the same scope as `map2` cannot then be used within the scalar<br>  function passed to `map2`. This is due to an [issue in XLA](https://github.com/openxla/xla/issues/14299).</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.reduce"><code><a class="type" href="Tensor.html#Tensor.reduce"><span class="name function">reduce</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Interfaces.Monoid"><span class="name type">Monoid</span></span>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">dtype</span>)&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">axes</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Util.List.Sorted"><span class="name type">Sorted</span></span>&ensp;<span class="type resolved" title="Data.Nat.LT"><span class="name function">LT</span></span>&ensp;<span class="boundvar">axes</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">axesInBounds</span>&ensp;:&ensp;<span class="type resolved" title="Data.List.Quantifiers.All.All"><span class="name type">All</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.flip"><span class="name function">flip</span></span>&ensp;<span class="type resolved" title="Data.List.InBounds"><span class="name type">InBounds</span></span>&ensp;<span class="boundvar">shape</span>)&ensp;<span class="boundvar">axes</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tag"><span class="name function">Tag</span></a>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="type resolved" title="Util.List.deleteAt"><span class="name function">deleteAt</span></span>&ensp;<span class="boundvar">axes</span>&ensp;<span class="boundvar">shape</span>)&ensp;<span class="boundvar">dtype</span>)</code></dt><dd><pre>  Reduce elements along one `axis` of a `Tensor` according to a specified `reducer` `Monoid`.<br>  For example, if `x = tensor [[0, 1, 2], [3, 4, 5]]`, then reduce @{Sum} 0 x` produces<br>  `tensor [3, 5, 7]`, and `reduce @{Sum} 1 x` produces `tensor [3, 12]`.<br>  <br>  **Note:** `Semigroup` doesn&apos;t use `Tag`, which limits the functions that can be used in<br>  `reduce`. However, the most commonly used semigroups don&apos;t need `Tag`, including `Sum`,<br>  `Prod`, `Min` and `Max`, so for ergonomics, we have opted to use `Monoid` as is. We can<br>  provide an overloaded variant if requested.<br>  <br>  **Note:** Values tagged in the same scope as `reduce` cannot then be used within the binary<br>  function supplied by the `Monoid`. This is due to an [issue in XLA](https://github.com/openxla/xla/issues/14299).<br>  <br>  @reducer How to reduce elements along the given `axis`.<br>  @axis The axis along which to reduce elements.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.sort"><code><a class="type" href="Tensor.html#Tensor.sort"><span class="name function">sort</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">dimension</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.List.InBounds"><span class="name type">InBounds</span></span>&ensp;<span class="boundvar">dimension</span>&ensp;<span class="boundvar">shape</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tag"><span class="name function">Tag</span></a>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>)</code></dt><dd><pre>  Sort the elements of a `Tensor` along a specified `dimension` according to a scalar-wise<br>  ordering. For sorting function `f`, elements are sorted such that for consecutive sorted<br>  elements `a` and `b`, either `f a b` is true, or `f a b` *and* `f b a` are false.<br>  <br>  **Note:** Sorting is not stable, meaning elements that compare equal according the ordering may<br>  be sorted in a different order to the order they appear in the input.<br>  <br>  **Note:** `sort` is limited to use comparison function without `Tag`. However, since the most<br>  commonly-used functions, including (&gt;), (&lt;), (&gt;=), and (&lt;=), don&apos;t use `Tag`, we have opted to<br>  omit it for ergonomics. We can trivially provide an overloaded variant if requested.<br>  <br>  **Note:** Values tagged in the same scope as `sort` cannot then be used within the scalar<br>  function passed to `sort`. This is due to an [issue in XLA](https://github.com/openxla/xla/issues/14299).<br>  <br>  For example, for `x = tensor [[1, 6, 4], [3, 2, 5]]`, `sort (&lt;) 0 x` produces<br>  `tensor [[1, 2, 4], [3, 6, 5]]`, while `sort (&lt;) 1 x` produces<br>  `tensor [[1, 4, 6], [2, 3, 5]]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.reverse"><code><a class="type" href="Tensor.html#Tensor.reverse"><span class="name function">reverse</span></a>&ensp;:&ensp;(<span class="boundvar">axes</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Util.List.Sorted"><span class="name type">Sorted</span></span>&ensp;<span class="type resolved" title="Data.Nat.LT"><span class="name function">LT</span></span>&ensp;<span class="boundvar">axes</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.List.Quantifiers.All.All"><span class="name type">All</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.flip"><span class="name function">flip</span></span>&ensp;<span class="type resolved" title="Data.List.InBounds"><span class="name type">InBounds</span></span>&ensp;<span class="boundvar">shape</span>)&ensp;<span class="boundvar">axes</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Reverse elements along the specified axes. For example, for<br>  ```<br>  x : Tensor [2, 3] S32<br>  x = tensor [[-2, -1,  0],<br>              [ 1,  2,  3]]<br>  ```<br>  `reverse [0] x` is<br>  ```<br>  x : Tensor [2, 3] S32<br>  x = tensor [[ 1,  2,  3],<br>              [-2, -1,  0]]<br>  ```<br>  `reverse [1] x` is<br>  ```<br>  x : Tensor [2, 3] S32<br>  x = tensor [[ 0, -1, -2],<br>              [ 3,  2,  1]]<br>  ```<br>  and `reverse [0, 1] x` is<br>  ```<br>  x : Tensor [2, 3] S32<br>  x = tensor [[ 3,  2,  1],<br>              [ 0, -1, -2]]<br>  ```<br>  <br>  **Note:** This function requires `axes` is ordered simply so that elements are unique.<br>  The ordering itself is irrelevant to the implementation, but ensures uniqueness without using<br>  proofs of contradiction that can be difficult for Idris to construct.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.(==)"><code><a class="type" href="Tensor.html#Tensor.(==)"><span class="name function">(==)</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Eq"><span class="name type">Eq</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a></code></dt><dd><pre>  Element-wise equality. For example, `tensor [1, 2] /= tensor [1, 3]` is<br>  `tensor [True, False]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;6</dd><dt id="Tensor.(/=)"><code><a class="type" href="Tensor.html#Tensor.(/=)"><span class="name function">(/=)</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Eq"><span class="name type">Eq</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a></code></dt><dd><pre>  Element-wise inequality. For example, `tensor [1, 2] /= tensor [1, 3]` is<br>  `tensor [False, True]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;6</dd><dt id="Tensor.(&lt;)"><code><a class="type" href="Tensor.html#Tensor.(&lt;)"><span class="name function">(<)</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Ord"><span class="name type">Ord</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a></code></dt><dd><pre>  Element-wise less than. For example, `tensor [1, 2, 3] &lt; tensor [2, 2, 2]` is<br>  `tensor [True, False, False]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;6</dd><dt id="Tensor.(&gt;)"><code><a class="type" href="Tensor.html#Tensor.(&gt;)"><span class="name function">(>)</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Ord"><span class="name type">Ord</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a></code></dt><dd><pre>  Element-wise greater than. For example, `tensor [1, 2, 3] &gt; tensor [2, 2, 2]` is<br>  `tensor [False, False, True]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;6</dd><dt id="Tensor.(&lt;=)"><code><a class="type" href="Tensor.html#Tensor.(&lt;=)"><span class="name function">(&lt;=)</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Ord"><span class="name type">Ord</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a></code></dt><dd><pre>  Element-wise less than or equal. For example, `tensor [1, 2, 3] &lt;= tensor [2, 2, 2]`<br>  is `tensor [True, True, False]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;6</dd><dt id="Tensor.(&gt;=)"><code><a class="type" href="Tensor.html#Tensor.(&gt;=)"><span class="name function">(&gt;=)</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Ord"><span class="name type">Ord</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a></code></dt><dd><pre>  Element-wise greater than or equal. For example,<br>  `tensor [1, 2, 3] &gt;= tensor [2, 2, 2]` is `tensor [False, True, True]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;6</dd><dt id="Tensor.(&amp;&amp;)"><code><a class="type" href="Tensor.html#Tensor.(&amp;&amp;)"><span class="name function">(&amp;&amp;)</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a></code></dt><dd><pre>  Element-wise boolean and. For example,<br>  `tensor [True, True, False, False] &amp;&amp; tensor [True, False, True, False]` is<br>  `tensor [True, False, False, False]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infixr&ensp;operator,&ensp;level&ensp;5</dd><dt id="Tensor.(||)"><code><a class="type" href="Tensor.html#Tensor.(||)"><span class="name function">(||)</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a></code></dt><dd><pre>  Element-wise boolean or. For example,<br>  `tensor [True, True, False, False] || tensor [True, False, True, False]` is<br>  `tensor [True, True, True, False]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infixr&ensp;operator,&ensp;level&ensp;4</dd><dt id="Tensor.not"><code><a class="type" href="Tensor.html#Tensor.not"><span class="name function">not</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a></code></dt><dd><pre>  Element-wise boolean negation. For example, `not (tensor [True, False])` is<br>  `tensor [False, True]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.select"><code><a class="type" href="Tensor.html#Tensor.select"><span class="name function">select</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Choose elements from two `Tensor`s based on a `Tensor` of predicates. For each element in the<br>  predicates, the output will use the corresponding element from `onTrue` if the element is<br>  truthy, else the element from `onFalse`. For example, for<br>  ```<br>  preds : Tensor [3] PRED<br>  preds = tensor [False, True, False]<br>  <br>  onTrue : Tensor [3] S32<br>  onTrue = tensor [1, 2, 3]<br>  <br>  onFalse : Tensor [3] S32<br>  onFalse = tensor [4, 5, 6]<br>  ```<br>  `select preds onTrue onFalse` is `tensor [4, 2, 6]`.<br>  <br>  @onTrue The elements to choose where the predicate elements are truthy.<br>  @onFalse The elements to choose where the predicate elements are falsy.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.cond"><code><a class="type" href="Tensor.html#Tensor.cond"><span class="name function">cond</span></a>&ensp;:&ensp;(<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">tt</span>,&ensp;(<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">ft</span>,&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>))&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">ts</span>&ensp;<span class="boundvar">tt</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tag"><span class="name function">Tag</span></a>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">ts</span>&ensp;<span class="boundvar">tt</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">fs</span>&ensp;<span class="boundvar">ft</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tag"><span class="name function">Tag</span></a>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">fs</span>&ensp;<span class="boundvar">ft</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tag"><span class="name function">Tag</span></a>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>)</code></dt><dd><pre>  Use a scalar predicate to choose which of two functions to evaluate. If the predicate is truthy,<br>  evaluate `onTrue` on the corresponding specified argument, otherwise evaluate `onFalse` on the<br>  corresponding specified argument. The result of the evaluated function is returned. For example,<br>  for<br>  ```<br>  x : Tensor [2] S32<br>  x = tensor [2, -1]<br>  <br>  y : Tensor [2, 2] S32<br>  y = tensor [[5, 6],<br>              [7, 8]]<br>  ```<br>  `cond (tensor True) (pure . (tensor 2 *)) x (pure . diag) y` produces `tensor [4, -2]` and<br>  `cond (tensor False) (pure . (tensor 2 *)) x (pure . diag) y` produces `tensor [5, 8]`.<br>  <br>  While both functions will be called for the purposes of defining the computation, only one will<br>  be evaluated with its specified argument. That is, this function short-circuits.<br>  <br>  **Note:** Values tagged in the same scope as `cond` cannot then be used in either function<br>  passed to `cond`. This is due to an [issue in XLA](https://github.com/openxla/xla/issues/14299).<br>  <br>  @onTrue The function to execute if the predicate is truthy.<br>  @onFalse The function to execute if the predicate is falsy.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.Vector.(@@)"><code><span class="type resolved" title="Tensor.Vector.(@@)"><span class="name function">(@@)</span></span>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Num"><span class="name type">Num</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">m</span>]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">m</span>]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Vector dot product with a tensor of any rank. The vector dot product is with the first axis of<br>  the right-hand side tensor. For example `tensor [0, 1, 2] @@ tensor [-1, -3, -1]` is<br>  `-1`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor.Matrix.(@@)"><code><span class="type resolved" title="Tensor.Matrix.(@@)"><span class="name function">(@@)</span></span>&ensp;:&ensp;(<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>,&ensp;<a class="type" href="Primitive.html#Primitive.Num"><span class="name type">Num</span></a>&ensp;<span class="boundvar">dtype</span>)&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">n</span>,&ensp;<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">m</span>]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">m</span>&ensp;<span class="type resolved" title="Prelude.Basics.(::)"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">tl</span>)&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.Nat.LTE"><span class="name type">LTE</span></span>&ensp;(<span class="type resolved" title="Prelude.Types.List.length"><span class="name function">length</span></span>&ensp;<span class="boundvar">tl</span>)&ensp;<span class="name constructor">1</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="boundvar">n</span>&ensp;<span class="type resolved" title="Prelude.Basics.(::)"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">tl</span>)&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Matrix multiplication with a matrix or vector. Contraction is along the last axis of the first<br>  and the first axis of the last. For example,<br>  ```<br>  x : Tensor [2, 3] S32<br>  x = tensor [[-1, -2, -3],<br>              [ 0,  1,  2]]<br>  <br>  y : Tensor [3, 1] S32<br>  y = tensor [[4, 0, 5]]<br>  <br>  z : Tensor [2, 1] S32<br>  z = x @@ y<br>  ```<br>  is<br>  ```<br>  z : Tensor [2, 1] S32<br>  z = tensor [-19, 10]<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor.contract"><code><a class="type" href="Tensor.html#Tensor.contract"><span class="name function">contract</span></a>&ensp;:&ensp;(<span class="boundvar">lBatch</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">rBatch</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">lContract</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">rContract</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">ls</span>&ensp;:&ensp;<a class="type" href="Types.html#Types.Shape"><span class="name function">Shape</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">rs</span>&ensp;:&ensp;<a class="type" href="Types.html#Types.Shape"><span class="name function">Shape</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.List.Quantifiers.All.All"><span class="name type">All</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.flip"><span class="name function">flip</span></span>&ensp;<span class="type resolved" title="Data.List.InBounds"><span class="name type">InBounds</span></span>&ensp;<span class="boundvar">ls</span>)&ensp;<span class="boundvar">lBatch</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.List.Quantifiers.All.All"><span class="name type">All</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.flip"><span class="name function">flip</span></span>&ensp;<span class="type resolved" title="Data.List.InBounds"><span class="name type">InBounds</span></span>&ensp;<span class="boundvar">rs</span>)&ensp;<span class="boundvar">rBatch</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.List.Quantifiers.All.All"><span class="name type">All</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.flip"><span class="name function">flip</span></span>&ensp;<span class="type resolved" title="Data.List.InBounds"><span class="name type">InBounds</span></span>&ensp;<span class="boundvar">ls</span>)&ensp;<span class="boundvar">lContract</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.List.Quantifiers.All.All"><span class="name type">All</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.flip"><span class="name function">flip</span></span>&ensp;<span class="type resolved" title="Data.List.InBounds"><span class="name type">InBounds</span></span>&ensp;<span class="boundvar">rs</span>)&ensp;<span class="boundvar">rContract</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Types.html#Types.Shape"><span class="name function">Shape</span></a></code></dt><dd><pre>  The output shape of a `dotGeneral` operation.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Tensor.dotGeneral"><code><a class="type" href="Tensor.html#Tensor.dotGeneral"><span class="name function">dotGeneral</span></a>&ensp;:&ensp;(<span class="boundvar">lBatch</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">rBatch</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">lContract</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">rContract</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Util.List.unique"><span class="name function">unique</span></span>&ensp;(<span class="boundvar">lBatch</span>&ensp;<span class="type resolved" title="Prelude.Types.List.(++)"><span class="name function">++</span></span>&ensp;<span class="boundvar">lContract</span>)&ensp;<span class="keyword">=</span>&ensp;<span class="type resolved" title="Prelude.Basics.True"><span class="name constructor">True</span></span>}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Util.List.unique"><span class="name function">unique</span></span>&ensp;(<span class="boundvar">rBatch</span>&ensp;<span class="type resolved" title="Prelude.Types.List.(++)"><span class="name function">++</span></span>&ensp;<span class="boundvar">rContract</span>)&ensp;<span class="keyword">=</span>&ensp;<span class="type resolved" title="Prelude.Basics.True"><span class="name constructor">True</span></span>}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">lInBoundsBatch</span>&ensp;:&ensp;<span class="type resolved" title="Data.List.Quantifiers.All.All"><span class="name type">All</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.flip"><span class="name function">flip</span></span>&ensp;<span class="type resolved" title="Data.List.InBounds"><span class="name type">InBounds</span></span>&ensp;<span class="boundvar">ls</span>)&ensp;<span class="boundvar">lBatch</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">rInBoundsBatch</span>&ensp;:&ensp;<span class="type resolved" title="Data.List.Quantifiers.All.All"><span class="name type">All</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.flip"><span class="name function">flip</span></span>&ensp;<span class="type resolved" title="Data.List.InBounds"><span class="name type">InBounds</span></span>&ensp;<span class="boundvar">rs</span>)&ensp;<span class="boundvar">rBatch</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">lInBoundsContract</span>&ensp;:&ensp;<span class="type resolved" title="Data.List.Quantifiers.All.All"><span class="name type">All</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.flip"><span class="name function">flip</span></span>&ensp;<span class="type resolved" title="Data.List.InBounds"><span class="name type">InBounds</span></span>&ensp;<span class="boundvar">ls</span>)&ensp;<span class="boundvar">lContract</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">rInBoundsContract</span>&ensp;:&ensp;<span class="type resolved" title="Data.List.Quantifiers.All.All"><span class="name type">All</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.flip"><span class="name function">flip</span></span>&ensp;<span class="type resolved" title="Data.List.InBounds"><span class="name type">InBounds</span></span>&ensp;<span class="boundvar">rs</span>)&ensp;<span class="boundvar">rContract</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Util.List.multiIndex"><span class="name function">multiIndex</span></span>&ensp;<span class="boundvar">lBatch</span>&ensp;<span class="boundvar">ls</span>&ensp;<span class="keyword">=</span>&ensp;<span class="type resolved" title="Util.List.multiIndex"><span class="name function">multiIndex</span></span>&ensp;<span class="boundvar">rBatch</span>&ensp;<span class="boundvar">rs</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Util.List.multiIndex"><span class="name function">multiIndex</span></span>&ensp;<span class="boundvar">lContract</span>&ensp;<span class="boundvar">ls</span>&ensp;<span class="keyword">=</span>&ensp;<span class="type resolved" title="Util.List.multiIndex"><span class="name function">multiIndex</span></span>&ensp;<span class="boundvar">rContract</span>&ensp;<span class="boundvar">rs</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">ls</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">rs</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<a class="type" href="Tensor.html#Tensor.contract"><span class="name function">contract</span></a>&ensp;<span class="boundvar">lBatch</span>&ensp;<span class="boundvar">rBatch</span>&ensp;<span class="boundvar">lContract</span>&ensp;<span class="boundvar">rContract</span>&ensp;<span class="boundvar">ls</span>&ensp;<span class="boundvar">rs</span>)&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Matrix multiplication.<br>  <br>  This is a much more general version of `(@@)`, in which you can specify any number of batch<br>  and contracting axes. Matrix multiplication is done over each contracting axis.<br>  The operation is vectorized over batch axes. For each contracting axis on the left-hand<br>  operand, there is one contracting axis on the right-hand operand. These can be different axes<br>  in each operand. The same is true for each batch axis.<br>  <br>  For example, we can vectorize over a typical rank-two matrix multiplication as follows: given<br>  two inputs tensors<br>  ```<br>  let x : Tensor [3, 4, 5, 6] F64<br>      y : Tensor [3, 4, 6, 7] F64<br>  ```<br>  we do<br>  ```<br>  let z : Tensor [3, 4, 5, 7] F64 = dotGeneral [0, 1] [0, 1] [3] [2] x y<br>  ```<br>  Here, we vectorized over the first two axes `[0, 1]`, and do standard matrix multiplication<br>  over the remaining axes by specifying the axes 3 and 2 respectively as contracting axes. Notice<br>  how the batch axes appear once each at the start of the output shape, and the contracting axis<br>  disappears. Remaining axes appear in order from left to right.<br>  <br>  Note this API is somewhat of a quickfix to bring general matrix multiplication to the tensor<br>    API. It is not thoroughly tested. Expect it to change in the future.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.(+)"><code><a class="type" href="Tensor.html#Tensor.(+)"><span class="name function">(+)</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Num"><span class="name type">Num</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Element-wise addition. For example, `tensor [1, 2] + tensor [3, 4]` is<br>  `tensor [4, 6]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;8</dd><dt id="Tensor.negate"><code><a class="type" href="Tensor.html#Tensor.negate"><span class="name function">negate</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Neg"><span class="name type">Neg</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Element-wise negation. For example, `- tensor [1, -2]` is `tensor [-1, 2]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;prefix operator, level&ensp;10</dd><dt id="Prelude.Num.negate"><code><span class="type resolved" title="Prelude.Num.negate"><span class="name function">negate</span></span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Num.Neg"><span class="name type">Neg</span></span>&ensp;<span class="boundvar">ty</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">ty</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">ty</span></code></dt><dd><pre>  The underlying of unary minus. `-5` desugars to `negate (fromInteger 5)`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Fixity Declaration</b>:&ensp;prefix operator, level&ensp;10</dd><dt id="Tensor.(-)"><code><a class="type" href="Tensor.html#Tensor.(-)"><span class="name function">(-)</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Neg"><span class="name type">Neg</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Element-wise subtraction. For example, `tensor [3, 4] - tensor [4, 2]` is<br>  `tensor [-1, 2]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declarations</b>:<br>  infixl&ensp;operator,&ensp;level&ensp;8<br>prefix operator, level&ensp;10</dd><dt id="Tensor.(*)"><code><a class="type" href="Tensor.html#Tensor.(*)"><span class="name function">(*)</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Num"><span class="name type">Num</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Element-wise multiplication. For example, `tensor [2, 3] * tensor [4, 5]` is<br>  `tensor [8, 15]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor.Scalarwise.(*)"><code><span class="type resolved" title="Tensor.Scalarwise.(*)"><span class="name function">(*)</span></span>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Num"><span class="name type">Num</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="boundvar">d</span>&ensp;<span class="type resolved" title="Prelude.Basics.(::)"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">ds</span>)&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="boundvar">d</span>&ensp;<span class="type resolved" title="Prelude.Basics.(::)"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">ds</span>)&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Multiplication by a scalar. For example, `tensor 2 * tensor [3, 5]` is<br>  `tensor [6, 10]`.<br>  <br>  The RHS is required to be non-scalar simply to avoid ambiguities with element-wise `(*)`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor.(/)"><code><a class="type" href="Tensor.html#Tensor.(/)"><span class="name function">(/)</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Fractional"><span class="name type">Fractional</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Element-wise floating point division. For example, `tensor [2, 3] / tensor [4, 5]` is<br>  `tensor [0.5, 0.6]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor.Scalarwise.(/)"><code><span class="type resolved" title="Tensor.Scalarwise.(/)"><span class="name function">(/)</span></span>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Fractional"><span class="name type">Fractional</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="boundvar">d</span>&ensp;<span class="type resolved" title="Prelude.Basics.(::)"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">ds</span>)&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="boundvar">d</span>&ensp;<span class="type resolved" title="Prelude.Basics.(::)"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">ds</span>)&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Floating point division by a scalar. For example, `tensor [3.4, -5.6] / tensor 2` is<br>  `tensor [1.7, -2.8]`.<br>  <br>  The LHS is required to be non-scalar simply to avoid ambiguities with element-wise `(/)`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor.div"><code><a class="type" href="Tensor.html#Tensor.div"><span class="name function">div</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.U64"><span class="name type">U64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">denom</span>&ensp;:&ensp;<a class="type" href="Literal.html#Literal.Literal"><span class="name type">Literal</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Literal.All.All"><span class="name type">All</span></span>&ensp;<span class="type resolved" title="Data.Nat.IsSucc"><span class="name type">IsSucc</span></span>&ensp;<span class="boundvar">denom</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.U64"><span class="name type">U64</span></a></code></dt><dd><pre>  Element-wise division of natural numbers. For example,<br>  `div (tensor [Scalar 13, Scalar 8]) [3, 4]` is `tensor [4, 2]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor.rem"><code><a class="type" href="Tensor.html#Tensor.rem"><span class="name function">rem</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.U64"><span class="name type">U64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">denom</span>&ensp;:&ensp;<a class="type" href="Literal.html#Literal.Literal"><span class="name type">Literal</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Literal.All.All"><span class="name type">All</span></span>&ensp;<span class="type resolved" title="Data.Nat.IsSucc"><span class="name type">IsSucc</span></span>&ensp;<span class="boundvar">denom</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.U64"><span class="name type">U64</span></a></code></dt><dd><pre>  Element-wise remainder for natural numbers. For example,<br>  `rem (tensor [Scalar 13, Scalar 8]) [3, 4]` is `tensor [1, 0]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.recip"><code><a class="type" href="Tensor.html#Tensor.recip"><span class="name function">recip</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise reciprocal. For example, `recip (tensor [-2, 0, 0.2])`<br>  is `tensor [-0.5, nan, 5]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.(^)"><code><a class="type" href="Tensor.html#Tensor.(^)"><span class="name function">(^)</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  Each element in `base` raised to the power of the corresponding element in `exponent`.<br>  example, `tensor [2, 25, -9] ^ tensor [3, -0.5, 0.5]` is `tensor [8, 0.2, nan]`.<br>  <br>  Note: The behaviour of this function is not well-defined at negative or positive infinity, or<br>    NaN.<br>  <br>  Note: The first root is used.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infixr&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor.abs"><code><a class="type" href="Tensor.html#Tensor.abs"><span class="name function">abs</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Abs"><span class="name type">Abs</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Element-wise absolute value. For example, `abs (tensor [-2, 3])` is `tensor [2, 3]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.exp"><code><a class="type" href="Tensor.html#Tensor.exp"><span class="name function">exp</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise natural exponential. For example, `exp (tensor [-1, 0, 2])` is<br>  `tensor [1 / euler, 1, pow euler 2]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.floor"><code><a class="type" href="Tensor.html#Tensor.floor"><span class="name function">floor</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise floor function. For example,<br>  `floor (tensor [-1.6, -1.5, -1.4, -1.0, 1.0, 1.4, 1.5, 1.6])` is<br>  `tensor [-2.0, -2.0, -2.0, -1.0, 1.0, 1.0, 1.0, 1.0]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.ceil"><code><a class="type" href="Tensor.html#Tensor.ceil"><span class="name function">ceil</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise ceiling function. For example,<br>  `ceil (tensor [-1.6, -1.5, -1.4, -1.0, 1.0, 1.4, 1.5, 1.6])` is<br>  `tensor [-1.0, -1.0, -1.0, -1.0, 1.0, 2.0, 2.0, 2.0]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.log"><code><a class="type" href="Tensor.html#Tensor.log"><span class="name function">log</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise natural logarithm. Negative inputs yield NaN output. For example,<br>  `log (tensor [1 / euler, 1, euler * euler])` is `tensor [-1, 0, 2]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.logistic"><code><a class="type" href="Tensor.html#Tensor.logistic"><span class="name function">logistic</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise logistic function equivalent to `1 / 1 + exp (-x)`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.sin"><code><a class="type" href="Tensor.html#Tensor.sin"><span class="name function">sin</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise sine.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.cos"><code><a class="type" href="Tensor.html#Tensor.cos"><span class="name function">cos</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise cosine.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.tan"><code><a class="type" href="Tensor.html#Tensor.tan"><span class="name function">tan</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise tangent.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.asin"><code><a class="type" href="Tensor.html#Tensor.asin"><span class="name function">asin</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise inverse sine.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.acos"><code><a class="type" href="Tensor.html#Tensor.acos"><span class="name function">acos</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise inverse cosine.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.atan"><code><a class="type" href="Tensor.html#Tensor.atan"><span class="name function">atan</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise inverse tangent.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.sinh"><code><a class="type" href="Tensor.html#Tensor.sinh"><span class="name function">sinh</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise hyperbolic sine.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.cosh"><code><a class="type" href="Tensor.html#Tensor.cosh"><span class="name function">cosh</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise hyperbolic cosine.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.tanh"><code><a class="type" href="Tensor.html#Tensor.tanh"><span class="name function">tanh</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise hyperbolic tangent.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.asinh"><code><a class="type" href="Tensor.html#Tensor.asinh"><span class="name function">asinh</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise inverse hyperbolic sine.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.acosh"><code><a class="type" href="Tensor.html#Tensor.acosh"><span class="name function">acosh</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise inverse hyperbolic cosine.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.atanh"><code><a class="type" href="Tensor.html#Tensor.atanh"><span class="name function">atanh</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise inverse hyperbolic tangent.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.erf"><code><a class="type" href="Tensor.html#Tensor.erf"><span class="name function">erf</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  An approximation to the element-wise error function.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.square"><code><a class="type" href="Tensor.html#Tensor.square"><span class="name function">square</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise square. For example, `square (tensor [-2, 0, 3])`<br>  is `tensor [4, 0, 9]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.sqrt"><code><a class="type" href="Tensor.html#Tensor.sqrt"><span class="name function">sqrt</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise square root. The first root is used. Negative inputs yield NaN output.<br>  For example, `sqrt (tensor [0, 9])` is `tensor [0, 3]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.min"><code><a class="type" href="Tensor.html#Tensor.min"><span class="name function">min</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Ord"><span class="name type">Ord</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  The element-wise minimum of the first argument compared to the second. For example,<br>  `min (tensor [-3, -1, 3]) (tensor [-1, 0, 1])` is `tensor [-3, -1, 1]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.max"><code><a class="type" href="Tensor.html#Tensor.max"><span class="name function">max</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Ord"><span class="name type">Ord</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  The element-wise maximum of the first argument compared to the second. For example,<br>  `max (tensor [-3, -1, 3]) (tensor [-1, 0, 1])` is `tensor [-1, 0, 3]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.argmax"><code><a class="type" href="Tensor.html#Tensor.argmax"><span class="name function">argmax</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Ord"><span class="name type">Ord</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tag"><span class="name function">Tag</span></a>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.U64"><span class="name type">U64</span></a>)</code></dt><dd><pre>  The first index of the maximum value in a vector. For example,<br>  `argmax (tensor [-1, 3, -2, -2, 3])` produces `tensor 1`. If the vector contains NaN values,<br>  `argmax` returns the index of the first NaN.<br>  <br>  **Note:** `argmax` uses `Tag` to work around what we believe to be an inconsistency in the XLA<br>  compiler&apos;s handling of NaN. Specifically, we have modified `argmax` to return the first index of<br>  the value returned by `reduce @{Max}`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.argmin"><code><a class="type" href="Tensor.html#Tensor.argmin"><span class="name function">argmin</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Ord"><span class="name type">Ord</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tag"><span class="name function">Tag</span></a>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.U64"><span class="name type">U64</span></a>)</code></dt><dd><pre>  The first index of the minimum value in a vector. For example,<br>  `argmin (tensor [-1, 3, -2, -2, 3])` produces `tensor 2`. If the vector contains NaN values,<br>  `argmin` returns the index of the first NaN.<br>  <br>  **Note:** `argmin` uses `Tag` to work around what we believe to be an inconsistency in the XLA<br>  compiler&apos;s handling of NaN. Specifically, we have modified `argmin` to return the first index of<br>  the value returned by `reduce @{Min}`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.cholesky"><code><a class="type" href="Tensor.html#Tensor.cholesky"><span class="name function">cholesky</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>,&ensp;<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>]&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>,&ensp;<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>]&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  Cholesky decomposition. Computes the lower triangular matrix `L` from the symmetric, positive<br>  semi-definite matrix `X` s.t. `X = L @@ L.T`. Values will be NaN if the input matrix is not<br>  positive semi-definite. The remaining matrix components - those not in the lower triangle or<br>  diagonal - will always be zero.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.Matrix.(|\)"><code><span class="type resolved" title="Tensor.Matrix.(|\)"><span class="name function">(|\)</span></span>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>,&ensp;<span class="boundvar">m</span>]&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>,&ensp;<span class="boundvar">n</span>]&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>,&ensp;<span class="boundvar">n</span>]&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  Solve the set of linear equations `a @@ x = b` for `x` where `a` is a lower-triangular matrix.<br>  `a` is given by the lower-triangular elements of the first argument. Values in the<br>  upper-triangular part are ignored. If `a` is lower-triangular already,<br>  this is written `a |\ b`.<br>  <br>  The operator is shaped like the lower-triangular portion of a matrix to signal that it uses<br>  this portion of its argument. This is in contrast to `(\|)`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor.Matrix.(\|)"><code><span class="type resolved" title="Tensor.Matrix.(\|)"><span class="name function">(\|)</span></span>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>,&ensp;<span class="boundvar">m</span>]&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>,&ensp;<span class="boundvar">n</span>]&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>,&ensp;<span class="boundvar">n</span>]&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  Solve the set of linear equations `a @@ x = b` for `x` where `a` is an upper-triangular<br>  matrix. `a` is given by the upper-triangular elements of the first argument. Values in the<br>  lower-triangular part are ignored. If `a` is upper-triangular already, this is written<br>  `a \| b`.<br>  <br>  The operator is shaped like the upper-triangular portion of a matrix to signal that it uses<br>  this portion of its argument. This is in contrast to `(|\)`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor.Vector.(|\)"><code><span class="type resolved" title="Tensor.Vector.(|\)"><span class="name function">(|\)</span></span>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>,&ensp;<span class="boundvar">m</span>]&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>]&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>]&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  Solve the set of linear equations `a @@ x = b` for `x` where `a` is a lower-triangular matrix.<br>  `a` is given by the lower-triangular elements of the first argument. Values in the<br>  upper-triangular part are ignored. If `a` is lower-triangular already,<br>  this is written `a |\ b`.<br>  <br>  The operator is shaped like the lower-triangular portion of a matrix to signal that it uses<br>  this portion of its argument. This is in contrast to `(\|)`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor.Vector.(\|)"><code><span class="type resolved" title="Tensor.Vector.(\|)"><span class="name function">(\|)</span></span>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>,&ensp;<span class="boundvar">m</span>]&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>]&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>]&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  Solve the set of linear equations `a @@ x = b` for `x` where `a` is an upper-triangular<br>  matrix. `a` is given by the upper-triangular elements of the first argument. Values in the<br>  lower-triangular part are ignored. If `a` is upper-triangular already, this is written<br>  `a \| b`.<br>  <br>  The operator is shaped like the upper-triangular portion of a matrix to signal that it uses<br>  this portion of its argument. This is in contrast to `(|\)`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor.trace"><code><a class="type" href="Tensor.html#Tensor.trace"><span class="name function">trace</span></a>&ensp;:&ensp;(<a class="type" href="Primitive.html#Primitive.Num"><span class="name type">Num</span></a>&ensp;<span class="boundvar">dtype</span>,&ensp;<span class="type resolved" title="Prelude.Num.Num"><span class="name type">Num</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Primitive.html#Primitive.PrimitiveRW"><span class="name type">PrimitiveRW</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>,&ensp;<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tag"><span class="name function">Tag</span></a>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">dtype</span>)</code></dt><dd><pre>  Sum the elements along the diagonal of the input. For example,<br>  `trace (tensor [[-1, 5], [1, 4]])` produces `3`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.Rand"><code><span class="keyword">0</span>&ensp;<a class="type" href="Tensor.html#Tensor.Rand"><span class="name function">Rand</span></a>&ensp;:&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A `Rand a` produces a pseudo-random value of type `a` from a `Tensor [1] U64` state.<br>  The state is updated each time a new value is generated.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Tensor.uniform"><code><a class="type" href="Tensor.html#Tensor.uniform"><span class="name function">uniform</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.U64"><span class="name type">U64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tag"><span class="name function">Tag</span></a>&ensp;(<a class="type" href="Tensor.html#Tensor.Rand"><span class="name function">Rand</span></a>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>))</code></dt><dd><pre>  Generate independent and identically distributed (IID) uniform samples bounded element-wise<br>  between `bound` and `bound&apos;`.<br>  <br>  `bound` and `bound&apos;` need not be ordered, and samples will be generated, elementwise, in<br>  [min bound bound&apos;, max bound bound&apos;). The exception is where the bounds are equal, in which<br>  case: if the bounds are finite, samples are generated at the common bound, else samples are NaN.<br>  <br>  The generated samples are a deterministic function of the input key and state, but may vary<br>  between backends and library versions.<br>  <br>  Example usage, multiplying two uniform samples<br>  ```<br>  x : Tag $ Tensor [3] F64<br>  x = do let key = tensor (Scalar 2)<br>             initialState = tensor [Scalar 0]<br>         rng &lt;- uniform key (fill 0.0) (fill 1.0)<br>         evalStateT initialState [| rng * rng |]<br>  ```<br>  <br>  @key Determines the stream of generated samples.<br>  @bound A bound of the samples. See full docstring for details.<br>  @bound&apos; A bound of the samples. See full docstring for details.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.normal"><code><a class="type" href="Tensor.html#Tensor.normal"><span class="name function">normal</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.U64"><span class="name type">U64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Rand"><span class="name function">Rand</span></a>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.XlaData.html#Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>)</code></dt><dd><pre>  Generate independent and identically distributed (IID) samples from the standard normal<br>  distribution.<br>  <br>  The generated samples are a deterministic function of the input key and state, but may vary<br>  between backends and library versions.<br>  <br>  Example usage, multiplying two normal samples<br>  ```<br>  x : Tag $ Tensor [3] F64<br>  x = let key = tensor (Scalar 2)<br>          rng = normal key<br>          initialState = tensor [Scalar 0]<br>       in evalStateT initialState [| rng * rng |]<br>  ```<br>  <br>  @key Determines the stream of generated samples.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd></dl></div><footer>Produced by Idris 2 version 0.7.0-9cb6c3e40</footer></body></html>